\documentclass[a4paper,12pt]{article}
\usepackage{booktabs} 
\usepackage{array}
\usepackage{longtable}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{setspace}
\usepackage{titling}
\usepackage{adjustbox}
\usepackage{algorithm}
\usepackage{algpseudocode} 
\pagenumbering{gobble}

\begin{document}

\begin{titlepage}
    \centering
    
    \includegraphics[width=0.25\textwidth]{images/logo.png}\par\vspace{1cm}
    
    {\scshape\LARGE Politecnico di Torino \par}
    \vspace{0.5cm}
    \vspace{2cm}
    
    {\Large\bfseries Microelectronic Systems\par}
    \vspace{1.5cm}
    

    \begin{flushleft}
        \large
        \begin{tabbing}
        \hspace{6cm} \= \kill
        \textbf{Student:} Luca Genca \hspace{1.5cm} \= \textbf{Student:} Alessio Delli Colli \\
        \textbf{ID:} s345156 \> \textbf{ID:} YYYYYYY \\
        \end{tabbing}
    \end{flushleft}
    
    \vfill

    \vfill
    {\large \today\par}
\end{titlepage}
\section{Intruduction}
The project consists in the creation of a dlx processor in vhdl.
The dlx is a RISC processor with a Harvard architecture, which means that it uses two different memories for data and instructions.
The processor is organized in a five-stage pipeline. At instruction fetch (IF) the control unit reads the current instruction pointed to by the PC; decode (DE) reads the register file and prepares operands and immediates; execute (EX) performs ALU operations; memory (MEM) performs data memory accesses; and writeback (WB) updates the register file.\\
It has 3 different types of instructions: 
\begin{table}[ht]
\centering
\begin{tabular}{|c|p{8cm}|}
\hline
\textbf{Instruction Type} & \textbf{Description and Example} \\
\hline
\textbf{R-type} & Instructions that operate on two source registers and store the result in a destination register. Example: \texttt{add \$r1, \$r2, \$r3} \\
\hline
\textbf{I-type} & Instructions that involve a register and an immediate value. Used for arithmetic with constants, memory access, and branching. Example: \texttt{addi \$r1, \$r2, 10} \\
\hline
\textbf{J-type} & Instructions perform unconditional jumps. Example: \texttt{j 40} \\
\hline
\end{tabular}
\caption{DLX Processor Instruction Types}
\end{table}\\
The complete implemented instruction set is the following:
\begin{table}[h!]
\centering
\caption{Implemented Instructions with Opcodes and Function Codes}
\begin{tabular}{|l|c|l|c|l|c|}
\hline
\textbf{I/J-type} & \textbf{Opcode} & \textbf{Int R-type} & \textbf{Func} & \textbf{Float R-type} & \textbf{Func} \\
\hline
j       & 0x02 & sll   & 0x02 & multf & 0x02 \\
jal     & 0x03 & srl   & 0x03 & divf  & 0x03 \\
beqz    & 0x04 & sra   & 0x07 &  &  \\
bnez    & 0x05 & add   & 0x20 &  &  \\
addi    & 0x08 & addu  & 0x21 &  &  \\
addui   & 0x09 & sub   & 0x22 &  &  \\
subi    & 0x0a & subu  & 0x23 &  &  \\
subui   & 0x0b & and   & 0x24 &  &  \\
andi    & 0x0c & or    & 0x25 &  &  \\
ori     & 0x0d & xor   & 0x26 &  &  \\
xori    & 0x0e & seq   & 0x28 &  &  \\
lhi     & 0x0f & sne   & 0x29 &  &  \\
jr      & 0x12 & slt   & 0x2a &  &  \\
jalr    & 0x13 & sgt   & 0x2b &  &  \\
slli    & 0x14 & sle   & 0x2c &  &  \\
nop     & 0x15 & sge   & 0x2d &  &  \\
srli    & 0x16 & mult  & 0x0e &  &  \\
srai    & 0x17 & div   & 0x0f &  &  \\
seqi    & 0x18 & sltu  & 0x3a &  &  \\
snei    & 0x19 & sgtu  & 0x3b &  &  \\
slti    & 0x1a & sgeu  & 0x3d &  &  \\
sgti    & 0x1b &       &      &  &  \\
slei    & 0x1c &       &      &  &  \\
sgei    & 0x1d &       &      &  &  \\
lb      & 0x20 &       &      &  &  \\
lbu     & 0x24 &       &      &  &  \\
lhu     & 0x25 &       &      &  &  \\
lw      & 0x23 &       &      &  &  \\
sb      & 0x28 &       &      &  &  \\
sw      & 0x2b &       &      &  &  \\
sltui   & 0x3a &       &      &  &  \\
sgtui   & 0x3b &       &      &  &  \\
sleui   & 0x3c &       &      &  &  \\
sgeui   & 0x3d &       &      &  &  \\
\hline
\end{tabular}
\end{table}
\clearpage
\section{Control Unit}
We used a hardwired control unit with a 23-bits control word
\begin{table}[ht]
  \centering
  \small
  \caption{Control signals and their meanings}
  \label{tab:control-signals}
  \begin{tabular}{@{}l p{0.72\textwidth}@{}}
    \toprule
    \textbf{Signal} & \textbf{Meaning} \\
    \midrule
    PC\_LATCH\_EN     & Enables updating of the program counter (PC) register. \\
    RegA\_LATCH\_EN   & Enables the register containing the first operand in I and R type instructions. \\
    RegB\_LATCH\_EN   & Enables the register containing the second operand in R type instructions. \\
    RegIMM\_LATCH\_EN & Enables the register containing the immediate value in I and J type instructions.. \\
    RFR1\_EN          & Enables read signal for register-file read port 1 (reads operand A). \\
    RFR2\_EN          & Enables read signal for register-file read port 2 (reads operand B). \\
    RF\_EN            & Global register-file enable. \\
    ALU\_OUTREG\_EN   & Enables saving of the ALU result into the ALU output register for the next stage. \\
    MUX\_B            & Selects signal for the ALU second operand multiplexer (e.g. choose between RegB / immediate). \\
    MUX\_A            & Selects signal for the ALU A second operand multiplexer (e.g. choose between RegA / PC). \\
    MEM\_LATCH\_EN    & Enables saving of address/data into the memory-stage pipeline register. \\
    EQ\_COND          & Equality condition (used for branching). \\
    JUMP\_EN          & Enables jumping (true for both jumps and branches). \\
    JUMP              & Indicates that a jump needs to be performed instead of a branch. \\
    BYTE              & Select byte-sized memory access (8-bit load/store). \\
    DRAM\_WE          & DRAM write enable. \\
    LMD\_LATCH\_EN    & Enables the memory register. \\
    SEL\_MEM\_ALU     & Select between memory data and ALU result for the write-back. \\
    RF\_WE            & Register-file write enable. \\
    JAL               & needed for the JAL instruction. \\
    HALF\_WORD        & Select half-word memory access (16-bit load/store). \\
    H\_L               & High/Low half/byte selector (chooses high-half vs low-half or upper vs lower byte when writing). \\
    S\_U              & Sign/Unsigned control for load and store: chooses between sign-extension (signed) or zero-extension (unsigned). \\
    \bottomrule
  \end{tabular}
\end{table}
\section{Datapath}
\begin{figure}[htbp]
    \centering
    \includegraphics[angle=90,width=\textwidth,height=0.9\textheight,keepaspectratio]{images/dlx.png}
    \caption{schematic of the entire datapath}
    \label{fig:entire_dlx}
\end{figure}
The datapath forms the structural backbone of the processor. Its components are:
\begin{itemize}
    \item \textbf{Branch Target Buffer (BTB):} saves recently encountered branches and respective targets, enabling the program counter to jump immediately when seeing a branch or jump, thus reducing stalls.
    
    \item \textbf{Register File:} an array of registers with two asynchronous read ports and one synchronous write port.
    
    \item \textbf{Arithmetic Logic Unit (ALU):} performs integer arithmetic, bitwise logic, shift, comparison operations, multiplications, and divisions.
    
    \item \textbf{Pipeline / Skew Registers:} small registers inserted between pipeline stages or to skew signals and align timing. These registers are also used for hazard detection.
\end{itemize}
\subsection{Branch Target Buffer (BTB)}
\begin{figure}[h!]
  \includegraphics{images/BTB.png}
\end{figure}
The BTB follows a simple prediction algorithm based on the last observed behavior of each branch. Whenever a branch or jump instruction is executed, the BTB entry corresponding to its program counter (PC) is updated with the new outcome â€” either \textit{taken} or \textit{not taken}. On subsequent encounters of the same instruction, the processor consults the BTB and uses the most recent prediction to decide whether to fetch from the branch target address or continue sequentially.
This one-bit prediction strategy may mispredict alternating branches, but it performs well for branches with stable behavior, such as loops.
\subsection{ALU}
The ALU is composed of several components: adder, comparator,logic unit, pipelined multiplier, shifter and divider.
\subsubsection{Adder}

The adder used in the ALU is based on the Pentium~4 adder architecture.

\begin{figure}[h]
  \centering
  \includegraphics{images/p4_adder.png}
  \caption{Pentium 4 adder structure}
\end{figure}

It is composed of two main parts:
\begin{enumerate}
  \item a sparse carry-generation tree, which computes the carries using group propagate and generate signals;
  \item a carry-select stage, which uses the carries from the sparse tree to select the correct partial sums.
\end{enumerate}

The sparse tree makes use of two types of blocks, \textbf{GP} and \textbf{G}, whose outputs are computed recursively as:
\[
G_{i:j} = G_{i:k} + P_{i:k} \cdot G_{k-1:j}
\]
\[
P_{i:j} = P_{i:k} \cdot P_{k-1:j}
\]

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.8\textwidth, keepaspectratio]{images/pg_network.png}
  \caption{Structure of the propagate/generate network}
\end{figure}
The carry-select block consists of several small ripple-carry adders (RCAs). Each RCA computes the partial sum assuming both possible carry-in values (0 and 1).A multiplexer then selects the correct partial sum based on the carry provided by the sparse tree.
\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth, keepaspectratio]{images/carry_select.png}
  \caption{Carry-select block}
\end{figure}
\subsubsection{Multiplier}
The multiplier is based on the Booth algorithm. The second operand is partitioned into groups, resulting in $N/2$ groups for an $N$-bit operand. Each group is processed by a Booth encoder, which determines the corresponding operation (e.g., $0$, $\pm A$, or $\pm 2A$).
\begin{figure}[h!]
  \centering
  \includegraphics{images/encoder.png}
  \caption{Booth encoder}
\end{figure}
The partial products selected by the encoders are then forwarded to a pipeline of adders. These adders accumulate the partial results, with multiplexers selecting the appropriate input based on the encoder outputs. 
Pipeline registers are inserted between stages to reduce the critical path and allow the multiplier to operate at a higher clock frequency.
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.8\textwidth, keepaspectratio]{images/booth.png}
  \caption{Booth multiplier structure}
\end{figure}

\subsubsection{comparator}
The comparator computes all signed and unsigned comparison conditions required by the DLX. It receives as inputs the operands $A$ and $B$, the sum produced by the ALU adder ($A - B$), and the carry-out bit. 
From these signals, the unit derives both signed and unsigned comparison flags.
To detect equality, the comparator checks if all bits of $A-B$ are zero. 
Signed comparisons are based on the sign of the subtraction result and the arithmetic overflow condition. The sign bits of $A$, $B$, and the result are used to compute the overflow flag, which is then combined with the result's sign to determine whether $A < B$. The remaining signed conditions ($A \le B$, $A > B$, $A \ge B$) are derived from the previous relation and the zero flag.
Unsigned comparisons rely solely on the carry-out from the subtraction. 
Since $A < B$ in unsigned arithmetic if and only if the subtraction does not generate a carry, the unit can compute unsigned relations directly from the carry bit and the zero flag. Overall, the comparator generates nine outputs: equality, less-than, greater-than, and the corresponding signed and unsigned variants, using only simple combinational logic.
\subsubsection{Logic unit}
The logic unit is based on the logic unit of the T2, which means that it contains two layers of nand gates.
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.7\textwidth, keepaspectratio]{images/logic_unit.png}
\end{figure}
\subsubsection{divider}
The divider is implemented using the non-restoring division algorithm. This method iteratively updates the remainder by adding or subtracting the shifted divisor depending on the sign of the current partial remainder. At each step, one quotient bit is generated: a positive remainder selects $+1$, while a negative remainder selects $-1$. The remainder is then doubled and corrected by subtracting or adding the divisor.
After $n$ iterations, the quotient is obtained.This quotient however uses $+1$ and $-1$ as digits, so it needs to be converted to binary. 
This approach avoids the need to restore the remainder during intermediate steps, simplifying the hardware and improving performance.
\begin{algorithm}[H]
\caption{Non-Restoring Division}
\begin{algorithmic}[1]
\State $R \gets N$
\State $D \gets D \ll n$
\For{$i = n-1$ down to $0$}
    \If{$R \ge 0$}
        \State $q(i) \gets +1$
        \State $R \gets 2R - D$
    \Else
        \State $q(i) \gets -1$
        \State $R \gets 2R + D$
    \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.7\textwidth, keepaspectratio]{images/divider.png}
\end{figure}
\section{Testing}
The tests have been conducted using 3 assembly programs:
\begin{itemize}
  \item \textbf{BTB\_test}: stores an array in memory, then loads each element and performs several operations (e.g., computing the maximum value, counting the number of negative elements, etc.). This test is designed to verify the correct functioning of the BTB by including a large number of branches (both forward and backward) as well as alternating branch directions.
  
  \item \textbf{mul\_div\_test}: a simple program that performs two multiplications in parallel, followed by two divisions where the second division is expected to stall.
  
  \item \textbf{all\_test}: tests the entire instruction set.
\end{itemize}
Each test verifies the correctness of the operations performed. If all tests pass, a success flag is raised.
\section{Physical Synthesis}
\subsection{Synthesis}
\subsection{Place and route}
\end{document}
